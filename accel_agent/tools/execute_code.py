"""Execute new Python scripts in sandbox (data analysis)."""

import asyncio
import tempfile
import textwrap
from pathlib import Path

from accel_agent.tools.base import BaseTool
from accel_agent.safety.code_analysis import CodeAnalyzer


class ExecuteCodeTool(BaseTool):
    name = "execute_code"
    description = """Execute a Python script for data analysis in a sandbox.
Available libraries: numpy, scipy, pandas, matplotlib, h5py, lmfit, sklearn.
Read from DATA_DIR/DATA_DIRS, write output to WORK_DIR. No network or control system access."""

    def __init__(self, config: dict):
        self.analyzer = CodeAnalyzer()
        self.data_dirs = config.get("data_dirs", [])
        self.scripts_dir = config.get("scripts_dir", "")
        self.work_dir = Path(config.get("work_dir", "logs/workspace"))
        self.work_dir.mkdir(parents=True, exist_ok=True)
        self.timeout = config.get("timeout_seconds", 120)
        self.max_memory_mb = config.get("max_memory_mb", 2048)

    def parameters_schema(self):
        return {
            "type": "object",
            "properties": {
                "code": {"type": "string", "description": "Python code to execute"},
                "description": {"type": "string", "description": "What this script does"},
                "save_as": {"type": "string", "description": "Optional filename to save script for reuse"},
            },
            "required": ["code", "description"],
        }

    async def execute(self, params):
        code = params["code"]
        analysis = self.analyzer.analyze(code)
        if not analysis.safe:
            return {
                "status": "blocked",
                "violations": analysis.violations,
                "hint": "Rewrite without blocked imports/calls. Use DATA_DIR for reads, WORK_DIR for writes.",
            }
        if params.get("save_as"):
            self._save_script(params["save_as"], code, params["description"])
        result = await self._run_sandboxed(code)
        output_files = self._collect_outputs()
        return {
            "status": "success" if result["returncode"] == 0 else "error",
            "stdout": result["stdout"][-5000:],
            "stderr": result["stderr"][-2000:],
            "output_files": output_files,
            "warnings": analysis.warnings,
        }

    async def _run_sandboxed(self, code: str) -> dict:
        wrapped = self._wrap_code(code)
        with tempfile.NamedTemporaryFile(mode="w", suffix=".py", delete=False) as f:
            f.write(wrapped)
            script_path = f.name
        try:
            proc = await asyncio.create_subprocess_exec(
                "python", script_path,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                env={**__import__("os").environ, "MPLBACKEND": "Agg"},
            )
            try:
                stdout, stderr = await asyncio.wait_for(proc.communicate(), timeout=self.timeout)
            except asyncio.TimeoutError:
                proc.kill()
                return {"returncode": -1, "stdout": "", "stderr": f"Timed out after {self.timeout}s"}
            return {
                "returncode": proc.returncode or 0,
                "stdout": (stdout or b"").decode(errors="replace"),
                "stderr": (stderr or b"").decode(errors="replace"),
            }
        finally:
            Path(script_path).unlink(missing_ok=True)

    def _wrap_code(self, code: str) -> str:
        data_dirs_repr = repr(self.data_dirs)
        return textwrap.dedent(f"""\
            import sys, os
            import matplotlib
            matplotlib.use('Agg')
            DATA_DIR = {repr(str(self.data_dirs[0]) if self.data_dirs else '/data')}
            DATA_DIRS = {data_dirs_repr}
            WORK_DIR = {repr(str(self.work_dir))}
            SCRIPTS_DIR = {repr(str(self.scripts_dir))}
            # User code below
        """) + code

    def _save_script(self, filename: str, code: str, description: str) -> None:
        path = Path(self.scripts_dir)
        path.mkdir(parents=True, exist_ok=True)
        header = f'"""\\n{description}\\nGenerated by accelerator agent\\n"""\\n\\n'
        (path / filename).write_text(header + code)

    def _collect_outputs(self) -> list[str]:
        if not self.work_dir.exists():
            return []
        return [str(p.relative_to(self.work_dir)) for p in self.work_dir.rglob("*") if p.is_file()]
